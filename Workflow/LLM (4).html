<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Never-Ending Story</title>
    <style>/* Lighter color palette for a more modern book-like feel */
        body {
            font-family: 'Palatino', 'Book Antiqua', Palatino, serif;
            background-color: #f0f0f0; /* Light gray for the background */
            margin: 0;
            padding: 20px;
            text-align: center;
        }

        h1 {
            margin-bottom: 32px; /* Adds space below the header */
            padding: 10px; /* Padding to increase focus on text */
        }
        /* Add this to the existing CSS */
        .gradient-square {
            width: 20px; /* Adjust size */
            height: 20px;
            position: absolute; /* Absolute position */
            top: 10px; /* Adjust to fix within AI chunk */
            left: 10px; /* Adjust to fix within AI chunk */
            outline: 1px solid rgba(192, 192, 192, 1); /* Solid outline for clear definition */
            border-radius: 4px; /* Slight rounding for aesthetics */
            overflow: hidden; /* Prevents overflow issues */
            z-index: 1;     
            background-clip: padding-box;
            animation: gradientShift 10s ease infinite;
            background-size: 400% 400%;
        }

        .page {
            max-width: 600px;
            position: relative;
            margin: 0 auto 20px auto; /* Centered horizontally with margin below */
            padding: 60px 20px;
            border: 10px solid rgba(192, 192, 192, 0.3);
            box-shadow: 4px 4px 8px rgba(128, 128, 128, 0.1);
            background: #ffffff;
            position: relative; /* Reference for absolutely positioned elements */
        }

        .chunk {
            text-align: left;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid rgba(192, 192, 192, 0.5); /* Light gray border */
            border-radius: 8px;
            background: rgba(240, 240, 240, 0.8); /* Very light gray */
            font-size: 18px;
            color: #4f4f4f; /* Medium gray text color */
        }

        /* CSS for AI chunk with adjusted padding */
        .ai-chunk {
            background: rgba(230, 230, 230, 0.8); /* Slightly different light gray */
            position: relative; /* Required for absolute positioning */
            padding-top: 12px;
            padding-left: 40px; /* Ensure space for the gradient square */
            padding-right: 10px; /* Adjust as needed for text alignment */
            margin: 10px 0; /* Consistent margins with other chunks */
            border: 1px solid rgba(192, 192, 192, 0.5); /* Light gray border for definition */
            border-radius: 8px; /* Rounded corners for a softer look */
        }

        .user-input {
            display: block;
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(192, 192, 192, 0.5);
            border-radius: 8px;
            background: rgba(245, 245, 245, 0.8);
            text-align: left;
            outline: none;
            box-sizing: border-box; /* Add this line */
            }

        .user-input:focus {
            border-color: rgba(192, 192, 192, 0.7); /* Slightly darker on focus */
            box-shadow: 0 0 0 2px rgba(192, 192, 192, 0.5); /* Subtle focus effect */
        }

        /* Minimap container - lighter colors */
        .minimap {
            position: absolute;
            top: 50%;
            right: -100px; /* Set to negative width of the minimap plus some extra margin */
            transform: translateY(-50%);
            width: 20px;
            height: 300px;
            background: rgba(192, 192, 192, 0.2);
            border: 1px solid rgba(192, 192, 192, 0.5);
            z-index: 10;
            transition: height 0.2s ease;
            border-radius: 8px;
        }

        /* Minimap progress bar - lighter colors */
        .minimap-progress {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(100, 100, 100, 0.7); /* Darker gray for progress bar */
            transition: height 0.1s ease;
            border-radius: 8px; /* Rounded corners for a softer look */
        }
        .button {
            display: inline-block;
            border: none;
            padding: 15px 30px; /* Increase padding for larger buttons */
            margin: 10px 5px; /* Margin for spacing between buttons */
            border-radius: 8px; /* Rounded corners for softer look */
            color: #4f4f4f;
            background: rgba(240, 240, 240, 0.8); /* Light gray, consistent with AI chunks */
            font-size: 16px; /* Match font size with AI chunks */
            font-family: 'Palatino';
            text-decoration: none;
            cursor: pointer;
            outline: none;
            transition: background 0.3s, box-shadow 0.3s; /* Smooth transitions for hover effects */
        }

        .button:hover {
            background: rgba(230, 230, 230, 0.9); /* Slightly darker on hover */
        }
        
        .speech-btn img, .tts-btn img {
            width: 20px; /* Set the size of the SVG icon */
            height: auto;
        }

        .active .speech-btn img {
            content: url('speech-recognition-active.svg');
            background-color: #48A7FF;
            color: white;
        }

        .active .tts-btn img {
            content: url('text-to-speech-active.svg');
            background-color: #48A7FF;
            color: white;
        }

        /* Specific styling for buttons in the button-container */
        .button-container {
            position: absolute; /* Relative to .page container */
            right: 0; /* Aligns to the right side of .page */
            bottom: -80px; /* Position below the .page container */
            display: flex;
            flex-direction: row; /* Horizontal layout */
            align-items: center;
            justify-content: flex-end; /* Right-align buttons */
            gap: 10px; /* Space between buttons */
        }

        .button-container .button {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px; /* Button width */
            height: 40px; /* Button height */
            padding: 0;
            margin: 5px;
            border-radius: 50%; /* Circle shape */
            background-color: #ffffff; /* Light gray background */
            transition: transform 0.3s, background-color 0.3s; /* Smooth transitions for hover effects */
            cursor: pointer;
        }

        .button-container .button img {
            width: 20px; /* Icon size inside the button */
            height: 20px;
        }

        .button-container .button:hover,
        .button-container .button:focus,
        .button-container .button:active {
            background-color: #ffffff; /* Darker on interaction */
            transform: scale(0.9); /* Scale down on hover/click */
        }

        .footer {
            min-height: 100px; /* Ensures at least 50 pixels of space */
            width: 100%; /* Covers the full width of the viewport */
            clear: both; /* Clears any floated elements above, if any */
        }



        
    </style>
<script type="module">
    // Import the functions you need from the SDKs you need
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
    import { getFirestore, collection, addDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
  
    // Your web app's Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAoRzih_7WHG-Hf6duUB9xHlcDcDOAyfBg",
      authDomain: "the-never-ending-story-a7b5f.firebaseapp.com",
      projectId: "the-never-ending-story-a7b5f",
      storageBucket: "the-never-ending-story-a7b5f.appspot.com",
      messagingSenderId: "33433722452",
      appId: "1:33433722452:web:dffddfbbf6c7278dd957c1",
      measurementId: "G-4VJTSJTD84"
    };
  
    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const db = getFirestore(app);
  </script>
</head>
<body>

    <!-- Main Page Content -->
    <div class="page">
        <h1>Never-Ending Story</h1>
        <div id="story"></div>
        <div class="minimap">
            <div class="minimap-progress" id="minimap-progress"></div>
        </div>
        <!-- Add this after the story div -->
    <div class="button-container">
        <button id="clearDatabaseBtn" class="button">
            <img src="clear-database-icon.svg" alt="Clear Database">
        </button>
        <button id="toggleSpeechRecognitionBtn" class="button">
            <img src="speech-recognition.svg" alt="Toggle Speech Recognition">
        </button>
        <button id="toggleTextToSpeechBtn" class="button">
            <img src="text-to-speech.svg" alt="Disable Text to Speech">
        </button>
        <button id="exportCSVBtn" class="button">
            <img src="export-csv.svg" alt="Export to CSV">
          </button>
    </div>
    </div>
    <footer class="footer"></footer>
    

    <!-- JavaScript -->
    <script>
        const socket = new WebSocket('ws://localhost:8765');
        // const socket = new WebSocket('ws://130.225.164.150:8765');
        socket.onopen = function(e) {
            console.log("Connection established!");
            addMessageToList("Connection established!");
        };

        socket.onmessage = function(event) {
            console.log(`Server: ${event.data}`);
            addMessageToList(`Server: ${event.data}`);
        };

        socket.onclose = function(event) {
            if (event.wasClean) {
                console.log(`Connection closed cleanly, code=${event.code}, reason=${event.reason}`);
                addMessageToList(`Connection closed cleanly.`);
            } else {
                // e.g. server process killed or network down
                console.log('Connection died');
                addMessageToList('Connection died.');
            }
        };

        socket.onerror = function(error) {
            console.log(`WebSocket Error: ${error.message}`);
            addMessageToList(`Error: ${error.message}`);
        };

        function sendMessage(userPart, aiPart) {
    const jsonMessage = JSON.stringify({ user: userPart, ai: aiPart });
    socket.send(jsonMessage);
    console.log(`Sent: ${jsonMessage}`);
}   
        let isDragging = false;
        let lastClientY;
        const minimapProgress = document.getElementById('minimap-progress');
        // Added variables for additional data
        let votingOptions = {};
        let emotionalFeedback = '';
        let toneChoice = '';

        // Function to update the minimap based on scroll position
        function updateMinimap() {
            const scrollPosition = window.scrollY; // Current scroll position
            const contentHeight = document.body.scrollHeight - window.innerHeight; // Total scrollable content height
            const progressPercentage = scrollPosition / contentHeight; // Calculate scroll percentage

            const minimapHeight = progressPercentage * 100; // Percentage height for the minimap
            minimapProgress.style.height = `${minimapHeight}%`; // Adjust the height of the minimap progress bar
        }

        // Event listener for scroll events
        window.addEventListener('scroll', updateMinimap); // Update minimap when scrolling

        const minimap = document.querySelector('.minimap');

        minimap.addEventListener('mousedown', function(event) {
            isDragging = true;
            lastClientY = event.clientY;
            event.preventDefault(); // Prevent text selection or other default actions
        });

        document.addEventListener('mousemove', function(event) {
            if (isDragging) {
                const deltaY = event.clientY - lastClientY;
                const scrollPosition = window.scrollY + deltaY * 5; // Adjust multiplier for sensitivity
                window.scrollTo(0, scrollPosition);
                lastClientY = event.clientY;
                updateMinimap(); // Update the minimap to reflect the new scroll position
            }
        });

        document.addEventListener('mouseup', function(event) {
            isDragging = false;
        });

        // Initial call to update the minimap
        updateMinimap(); // Ensure minimap reflects the correct position upon page load


        const storyDiv = document.getElementById('story');
        const apiKey = ''; //Dont push this
        const dbName = 'NeverEndingStoryDB';
        const storeName = 'story';
        const messages = [];

        // Added variables for speech recognition and synthesis
        let continuationOptions = [];
        let isSpeechRecognitionEnabled = false;
        let isTextToSpeechEnabled = false;
        const speechRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition)();
        speechRecognition.lang = 'en-US';
        speechRecognition.continuous = true;  // Set to true for continuous recognition
        speechRecognition.interimResults = true;  // Set to true to get results immediately
        speechRecognition.maxAlternatives = 1;

        function speakText(text) {
            if (isTextToSpeechEnabled && 'speechSynthesis' in window) {
                const voices = window.speechSynthesis.getVoices();
                const voice = voices.find(v => v.name === 'Google UK English Female');
                if (voice) {
                    console.log('Speaking text:', text);
                    window.speechSynthesis.cancel(); // Cancel any ongoing speech
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.voice = voice;
                    window.speechSynthesis.speak(utterance);
                }
            }
        }

        // Initialize IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 1);

                request.onupgradeneeded = function (event) {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(storeName)) {
                        db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
                    }
                };

                request.onsuccess = function (event) {
                    resolve(event.target.result);
                };

                request.onerror = function (event) {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }
        

        async function saveStoryChunk(content, type, file = null) {
    let imageUrl = null;

    if (file) {
        // Upload image to Firebase Storage and get the URL
        const storageRef = ref(storage, `images/${file.name}`);
        try {
            const snapshot = await uploadBytes(storageRef, file);
            imageUrl = await getDownloadURL(snapshot.ref);
            console.log('Image uploaded and available at', imageUrl);
        } catch (error) {
            console.error('Error uploading image:', error);
            return;
        }
    }

    // Save the story chunk to Firestore
    try {
        await addDoc(collection(db, "stories"), {
            content: content,
            type: type,
            imageUrl: imageUrl,
            timestamp: new Date(),
            votingOptions: JSON.stringify(votingOptions) || null,
            emotionalFeedback: emotionalFeedback || null,
            toneChoice: toneChoice || null,
            continuationOptions: continuationOptions || null
        });
        console.log("Story chunk saved!");
    } catch (e) {
        console.error("Error adding document: ", e);
    }
}


        function createGradientSquare() {
            const gradientSquare = document.createElement('div');
            gradientSquare.className = 'gradient-square'; // CSS class for styling
            return gradientSquare; // Return the created element
        }

        // Function to create and append a new story chunk with word-by-word animation
        function appendStoryChunkWithAnimation(content) {
            const chunk = document.createElement('div');
            const gradientSquare = document.createElement('div');
            gradientSquare.className = 'gradient-square';
            chunk.appendChild(gradientSquare);
            chunk.className = 'chunk ai-chunk';
            storyDiv.appendChild(chunk);

            const words = content.split(/\s+/);
            let currentIndex = 0;

            function typeNextWord() {
                if (currentIndex < words.length) {
                    chunk.append(words[currentIndex] + ' ');
                    currentIndex++;
                    setTimeout(typeNextWord, 50); // Adjust typing speed
                } else {
                    addUserInputField(); // Add user input field after animation
                    saveStoryChunk(content, 'ai');
                    speakText(content); // Save AI chunk to the database
                    sendMessage(content);
                }
            }

            setTimeout(() => {
                typeNextWord();
                animateGradient();
                speakText(content);
            }, 50);
            speakText(content); // Start typing
        }



            function animateGradient() {
            const gradientSquares = document.querySelectorAll('.gradient-square');
            const colors = [
                [200, 255, 255], // Icy blue
                [150, 200, 255], // Light blue
                [100, 150, 255], // Medium blue
                [50, 100, 200], // Dark blue
                [25, 50, 100], // Darker blue
                [200, 230, 255] // Pale blue
            ];
            let step = 0;
            const colorIndices = [0, 1, 2, 3];
            const gradientSpeed = 0.01; // Moderately fast for noticeable movement

            function updateGradient() {
                gradientSquares.forEach((square) => {
                    const c0_0 = colors[colorIndices[0]];
                    const c0_1 = colors[colorIndices[1]];
                    const c1_0 = colors[colorIndices[2]];
                    const c1_1 = colors[colorIndices[3]];
                    const istep = 1 - step;
                    const r1 = Math.round(istep * c0_0[0] + step * c0_1[0]);
                    const g1 = Math.round(istep * c0_0[1] + step * c0_1[1]);
                    const b1 = Math.round(istep * c0_0[2] + step * c0_1[2]);
                    const color1 = `rgb(${r1}, ${g1}, ${b1})`;
                    const r2 = Math.round(istep * c1_0[0] + step * c1_1[0]);
                    const g2 = Math.round(istep * c1_0[1] + step * c1_1[1]);
                    const b2 = Math.round(istep * c1_0[2] + step * c1_1[2]);
                    const color2 = `rgb(${r2}, ${g2}, ${b2})`;

                    square.style.background = `linear-gradient(to right, ${color1}, ${color2})`;
                });

                step += gradientSpeed;
                if (step >= 1) {
                    step %= 1;
                    colorIndices[0] = colorIndices[1];
                    colorIndices[2] = colorIndices[3];
                    colorIndices[1] = (colorIndices[1] + Math.floor(1 + Math.random() * (colors.length - 1))) % colors.length;
                    colorIndices[3] = (colorIndices[3] + Math.floor(1 + Math.random() * (colors.length - 1))) % colors.length;
                }

                requestAnimationFrame(updateGradient);
            }

            updateGradient();
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            animateGradient(); // Start the gradient animation when the page loads
        });


        function toggleTextToSpeech() {
            isTextToSpeechEnabled = !isTextToSpeechEnabled;
            const btn = document.getElementById('toggleTextToSpeechBtn');
            const icon = btn.querySelector('img');
            if (isTextToSpeechEnabled) {
                btn.classList.add('active');
                btn.style.backgroundColor = '#48A7FF'; // Blue background when active
                icon.src = 'text-to-speech-active.svg'; // Path to white icon
                icon.style.color = '#FFFFFF'; // Set the color to white
            } else {
                btn.classList.remove('active');
                btn.style.backgroundColor = ''; // Grey background when inactive
                icon.src = 'text-to-speech.svg'; // Path to default icon
                icon.style.color = ''; // Reset the color
            }
        }

        function toggleSpeechRecognition() {
            isSpeechRecognitionEnabled = !isSpeechRecognitionEnabled;
            const btn = document.getElementById('toggleSpeechRecognitionBtn');
            const icon = btn.querySelector('img');
            if (isSpeechRecognitionEnabled) {
                btn.classList.add('active');
                btn.style.backgroundColor = '#48A7FF'; // Blue background when active
                icon.src = 'speech-recognition-active.svg'; // Path to white icon
                icon.style.color = '#FFFFFF'; // Set the color to white
                speechRecognition.start();
            } else {
                btn.classList.remove('active');
                btn.style.backgroundColor = ''; // Grey background when inactive
                icon.src = 'speech-recognition.svg'; // Path to default icon
                icon.style.color = ''; // Reset the color
                speechRecognition.stop();
            }
        }

        speechRecognition.addEventListener('result', function (event) {
            const userInput = storyDiv.querySelector('.user-input:last-of-type');
            if (userInput) {
                const speechResult = event.results[0][0].transcript;
                userInput.value = speechResult;
                console.log(`Speech recognized: ${speechResult}`);
            }
        });

        speechRecognition.addEventListener('end', function () {
            console.log("Speech recognition ended");
            if (isSpeechRecognitionEnabled) {
                speechRecognition.start();
            }
        });

        const toggleTextToSpeechBtn = document.getElementById('toggleTextToSpeechBtn');
        toggleTextToSpeechBtn.addEventListener('click', toggleTextToSpeech);

        const toggleSpeechRecognitionBtn = document.getElementById('toggleSpeechRecognitionBtn');
        toggleSpeechRecognitionBtn.addEventListener('click', toggleSpeechRecognition);

        async function continueStory() {
    const userInput = storyDiv.querySelector('.user-input:last-of-type');
    if (userInput) {
        const userInputText = userInput.value.trim();
        if (userInputText) {
            const userInputChunk = document.createElement('div');
            userInputChunk.className = 'chunk';
            userInputChunk.textContent = userInputText;

            userInput.replaceWith(userInputChunk); // Replace input with text first

            messages.push({ "role": "user", "content": userInputText });

            saveStoryChunk(userInputText, 'user'); // Store user input in IndexedDB

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: "gpt-3.5-turbo",
                    messages,
                    max_tokens: 30
                })
            });

            const data = await response.json();
            const storyContinuation = data.choices[0].message.content;

            appendStoryChunkWithAnimation(storyContinuation); // AI-generated content with animation

            messages.push({ "role": "assistant", "content": storyContinuation });

            // Send both user and AI parts to the server
            sendMessage(userInputText, storyContinuation);
        }
    }
}

        function loadStory() {
            initDB().then((db) => {
                const transaction = db.transaction([storeName], 'readonly');
                const objectStore = transaction.objectStore(storeName);
                const request = objectStore.openCursor();

                request.onsuccess = function (event) {
                    const cursor = event.target.result;
                    if (cursor) {
                        const content = cursor.value.content;
                        const type = cursor.value.type;

                        appendStoryChunk(content, type); // Append chunk and ensure gradient square for AI chunks

                        cursor.continue(); // Continue loading more chunks
                    } else {
                        // After loading, ensure an input field is present
                        if (!storyDiv.querySelector('.user-input')) {
                            addUserInputField(); // Add if there's no input field
                        }
                    }
                };
            });
        }

        function appendStoryChunk(content, type) {
            const chunk = document.createElement('div');
            chunk.className = 'chunk';
            chunk.textContent = content; // Set the chunk text content

            if (type === 'ai') {
                chunk.classList.add('ai-chunk');
                const gradientSquare = createGradientSquare(); // Ensure a gradient square is created
                chunk.appendChild(gradientSquare); // Append the gradient square to the AI chunk
                storyDiv.appendChild(chunk); // Append to the story div
                animateGradient(); // Ensure gradient animation is applied immediately after adding the chunk
            } else {
                storyDiv.appendChild(chunk); // Append regular chunks without gradient
            }
        }

        let voteCounts = { option1: 0, option2: 0, option3: 0, option4: 0 };
        const voteThreshold = 15;

        function addVotingInputField() {
            const votingDiv = document.createElement('div');
            votingDiv.className = 'user-input';
            votingDiv.innerHTML = `
                <p>Please vote for the next part of the story:</p>
                <button class="button" onclick="castVote('option1')">Option 1</button>
                <button class="button" onclick="castVote('option2')">Option 2</button>
                <button class="button" onclick="castVote('option3')">Option 3</button>
                <button class="button" onclick="castVote('option4')">Option 4</button>
                <div id="voteResults">
                    Votes: Option 1 - 0, Option 2 - 0, Option 3 - 0, Option 4 - 0
                </div>
            `;
            storyDiv.appendChild(votingDiv);
            votingDiv.scrollIntoView();

            // Initialize votingOptions
            votingOptions = { option1: 0, option2: 0, option3: 0, option4: 0 };
        }

        function castVote(option) {
            voteCounts[option]++;
            votingOptions[option]++;
            updateVoteDisplay();
            checkVoteCount();
        }

        function updateVoteDisplay() {
            const resultsDiv = document.getElementById('voteResults');
            resultsDiv.textContent = `Votes: Option 1 - ${voteCounts.option1}, Option 2 - ${voteCounts.option2}, Option 3 - ${voteCounts.option3}, Option 4 - ${voteCounts.option4}`;
        }


        function resetVotes() {
            voteCounts = { option1: 0, option2: 0, option3: 0, option4: 0 };
        }

        function checkVoteCount() {
            for (const option in voteCounts) {
                if (voteCounts[option] >= voteThreshold) {
                    fetchStoryContinuation(option); // Fetch or generate the story continuation based on the winning option
                    resetVotes();
                    break;
                }
            }
        }

        async function fetchStoryContinuation(option) {
            // Remove the voting options from display
            document.querySelector('.user-input').remove();
            
            // This is a placeholder for how you might decide to generate or fetch story content
            // Here, you might use `option` to decide the tone or direction of the story
            const prompt = `Continue the story in the direction chosen by ${option}. What happens next? Don't name the option at all. Just continue the story.`;
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: "gpt-3.5-turbo",
                    messages: [{ role: "system", content: prompt }],
                    max_tokens: 30
                })
            });
            const data = await response.json();
            if (data.choices && data.choices.length > 0) {
                appendStoryChunkWithAnimation(data.choices[0].message.content);
            }
        }


        let inputCounter = 0;
        let inputTypeIndex = 0; // Added to cycle through input types

        function addUserInputField() {
            inputCounter++;
            if (inputCounter % 15 === 0) {
                // Cycle through input types, including the new voting input type
                inputTypeIndex = (inputTypeIndex + 1) % 4;
                switch (inputTypeIndex) {
                    case 0:
                        addUserChoiceInputField();
                        break;
                    case 1:
                        addEmotionalFeedbackInputField();
                        break;
                    case 2:
                        addPrePromptsInputField();
                        break;
                    case 3:
                        addVotingInputField();
                        break;
                }
            } else {
                const userInput = document.createElement('textarea');
                userInput.className = 'user-input';
                userInput.placeholder = 'Your turn...';
                userInput.addEventListener('keypress', function (event) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        continueStory();
                    }
                });
                storyDiv.appendChild(userInput);
                userInput.scrollIntoView();
            }
        }

        function addUserChoiceInputField() {
            const choiceDiv = document.createElement('div');
            choiceDiv.className = 'user-input';
            choiceDiv.innerHTML = `
                <p>Do you want me to make the story more serious, funny, sad, or intelligent?</p>
                <button class="button" onclick="changeStoryTone('serious')">Serious</button>
                <button class="button" onclick="changeStoryTone('funny')">Funny</button>
                <button class="button" onclick="changeStoryTone('sad')">Sad</button>
                <button class="button" onclick="changeStoryTone('intelligent')">Intelligent</button>
            `;
            storyDiv.appendChild(choiceDiv);
            choiceDiv.scrollIntoView();
        }

        let currentTone = 'neutral'; // Default story tone

        function changeStoryTone(tone) {
            console.log("Story tone changed to: " + tone);
            currentTone = tone;
            document.querySelector('.user-input').remove(); // Ensure any existing input box is removed
            fetchNextAIChunk(); // Automatically fetch and continue the story with the new tone
            toneChoice = tone;
        }

        async function generateAIContentWithTone() {
            const lastMessage = messages.length > 0 ? messages[messages.length - 1].content : "Start of the story. ";
            const prompt = `Continue the story in a ${currentTone} tone: ${lastMessage}`;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: "gpt-3.5-turbo",
                    messages: [{ role: "system", content: `Generate a story continuation in a ${currentTone} tone.` },
                               { role: "user", content: prompt }],
                    max_tokens: 30,
                    n: 1,
                    stop: null,
                    temperature: 0.7
                })
            });
            const data = await response.json();
            appendStoryChunkWithAnimation(data.choices[0].message.content); // Display the AI-generated continuation in the specified tone
        }

        function addEmotionalFeedbackInputField() {
    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'user-input';
    feedbackDiv.innerHTML = `
        <p>How does this make you feel?</p>
        <textarea id="feedbackText" class="user-input" placeholder="Your feelings..."></textarea>
        <button class="button" onclick="saveFeedbackAndRemove()">Submit</button>
    `;
    storyDiv.appendChild(feedbackDiv);
    feedbackDiv.scrollIntoView();

    // Add event listener to the textarea
    const feedbackTextArea = document.getElementById('feedbackText');
    feedbackTextArea.addEventListener('keypress', function(event) {
        // Check if the Enter key is pressed
        if (event.key === 'Enter' && !event.shiftKey) {  // Ensure Shift+Enter does not submit to allow line breaks
            event.preventDefault(); // Prevent the default action to stop from adding a newline
            saveFeedbackAndRemove(); // Call the function to save feedback and remove the input field
        }
    });
}

        function saveFeedbackAndRemove() {
            const feedbackTextElement = document.getElementById('feedbackText');
            if (feedbackTextElement) {
                const feedback = feedbackTextElement.value;
                console.log("Feedback: " + feedback); // Log feedback
                // You can add code here to save the feedback to a CSV file
                document.querySelector('.user-input').remove(); // Remove the feedback box
                fetchNextAIChunk(); // Continue the story automatically without additional user input
                emotionalFeedback = feedback;
            } else {
                console.error("Could not find the feedback input element.");
            }
        }

        async function fetchNextAIChunk() {
            if (currentTone !== 'neutral') {
                await generateAIContentWithTone();
            } else {
                const lastMessage = messages.length > 0 ? messages[messages.length - 1].content : "The beginning of the story.";
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-3.5-turbo",
                        messages: [{ role: "system", content: "Continue this story." }, { role: "user", content: lastMessage }],
                        max_tokens: 30
                    })
                });
                const data = await response.json();
                if (data.choices && data.choices.length > 0) {
                    appendStoryChunkWithAnimation(data.choices[0].message.content);
                }
            }
        }

        async function addPrePromptsInputField() {
            const promptsDiv = document.createElement('div');
            promptsDiv.className = 'user-input';
            promptsDiv.innerHTML = '<p>Choose one of the continuations:</p>';
            const continuations = await fetchContinuations();

            continuations.forEach(continuation => {
                const btn = document.createElement('button');
                btn.className = 'button';
                btn.innerText = continuation;
                btn.onclick = () => {
                    document.querySelector('.user-input').remove(); // Remove the pre-prompt box
                    appendStoryChunkWithAnimation(continuation);
                };
                promptsDiv.appendChild(btn);
            });

            storyDiv.appendChild(promptsDiv);
            promptsDiv.scrollIntoView();
        }

        async function fetchContinuations() {
            const lastMessage = messages.length > 0 ? messages[messages.length - 1].content : "Start of story";
            const prompt = `Continue the story: ${lastMessage}`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-3.5-turbo",
                        messages: [{ role: "system", content: "Suggest a different way to continue this story. It should be only one suggestion with one sentence, no numbers or bullet points and NO QUOTES. Just the sentence." },
                                { role: "user", content: prompt }],
                        max_tokens: 30,
                        n: 3, // Request 3 completions
                        stop: null,
                        temperature: 0.9
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const data = await response.json();
            if (data.choices && Array.isArray(data.choices)) {
            const continuations = data.choices.map(choice => choice.message.content.trim());
            continuationOptions = continuations;
            return continuations;
            } else {
            // Handle the case where data.choices is undefined or not an array
            console.error("Unexpected response format:", data);
            return []; // Return an empty array or a default response
            }
        } catch (error) {
            console.error("Failed to fetch continuations:", error);
            return []; // Handle errors by returning an empty array or a default response
        }
        }

        function appendUserChoiceContinuation(text) {
            appendStoryChunkWithAnimation(text);
        }
        


        function generateCSVData() {
        const csvData = [];

        // Get all story chunks from IndexedDB
        initDB().then(db => {
            const transaction = db.transaction([storeName], 'readonly');
            const objectStore = transaction.objectStore(storeName);
            const request = objectStore.openCursor();

            request.onsuccess = function(event) {
            const cursor = event.target.result;
            if (cursor) {
                const data = cursor.value;
                csvData.push(data);
                cursor.continue();
            } else {
                // Generate CSV string from csvData
                const csvString = convertToCSV(csvData);

                // Create a download link for the CSV file
                const downloadLink = document.createElement('a');
                downloadLink.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent(csvString));
                downloadLink.setAttribute('download', 'story.csv');
                downloadLink.style.display = 'none';
                document.body.appendChild(downloadLink);

                // Click the download link to trigger the download
                downloadLink.click();

                // Remove the link after the download is complete
                document.body.removeChild(downloadLink);
            }
            };
        });
        }

        function convertToCSV(data) {
            const headers = ['content', 'type', 'votingOptions', 'emotionalFeedback', 'toneChoice', 'continuationOptions'];
            const csvRows = [];

            // Add headers
            csvRows.push(headers.join(','));

            // Add data rows
            for (const row of data) {
                const values = headers.map(header => {
                    const value = row[header];
                    if (value === null) {
                        return '';
                    } else if (Array.isArray(value)) {
                        return `"${value.join('|')}"`;
                    } else if (typeof value === 'object') {
                        return `"${JSON.stringify(value)}"`;
                    } else if (header === 'votingOptions' && typeof value === 'string') {
                        // Handle votingOptions as a JSON string
                        return `"${value.replace(/\|/g, ', ')}"`;
                    } else {
                        return value.replace(/,/g, ''); // Remove commas from the value
                    }
                });
                csvRows.push(values.join(','));
            }

            return csvRows.join('\n');
        }

        // Function to clear the database
        function clearDatabase() {
            initDB().then(db => {
                const transaction = db.transaction([storeName], 'readwrite');
                const objectStore = transaction.objectStore(storeName);
                objectStore.clear();
                location.reload(); // Reload the page after clearing the database
            });
        }
        const clearDatabaseBtn = document.getElementById('clearDatabaseBtn');
        clearDatabaseBtn.addEventListener('click', clearDatabase);
        const exportCSVBtn = document.getElementById('exportCSVBtn');
        exportCSVBtn.addEventListener('click', generateCSVData);

        loadStory(); // Load story on startup
    </script>
</body>
</html>
